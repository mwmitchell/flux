(ns flux.client
  (:require [flux.update :refer [create-doc]]
            [flux.query :refer [create-query]]
            [flux.converter :refer [->clojure]])
  (:import [org.apache.solr.client.solrj SolrClient]))

(defn query 
  "query solr 
   
   client
   : connection to work with (will be hidden by fn-generator)
   
   query 
   : string to send to solr most simple use `*:*`"
  [^SolrClient client query & [options]]
  (->clojure (.query client (create-query query options))))

(defn request 
  "sending a query request to solr 
   
   client
   : connection to work with (will be hidden by fn-generator)
   
   request
   : request generated by create-query-request"  
  [^SolrClient client request]
  (->clojure (.request client request)))

(defmulti add
  "Takes a map or list of maps which are converted into 
   InputDocuments and be added to the server.
   
   client
   : connection to work with (will be hidden by fn-generator)
   
   doc
   : map or maps to be added to solr"
  (fn [_ input & _]
    (cond
     (map? input) :one
     :else :default)))

(defmethod add :one [^SolrClient client doc & {:as opts}]
  (->clojure (.add client (create-doc doc))))

(defmethod add :default [^SolrClient client docs & {:as opts}]
  (->clojure (.add client ^java.util.Collection (map create-doc docs))))

(defn commit 
  "Commits the pending changes to solr
   
   client
   : connection to work with (will be hidden by fn-generator)"
  [^SolrClient client & {:as opts}]
  (->clojure (.commit client)))

(letfn [(v [x]
          (cond (keyword? x) (name x) :else (str x)))]
  (defn delete-by-id 
    "Deletes a list of documents by unique ID. Doesn't work for child/nested docs.
     
     client
     : connection to work with (will be hidden by fn-generator)
     
     ids
     : a single id to delete or a list with ids of documents to delete"
    [^SolrClient client ids & {:as opts}]
    (->clojure
     (let [ids (if (coll? ids) (map v ids) (v ids))]
      (.deleteById ^SolrClient client ^java.util.List ids)))))

(defn delete-by-query 
  "Deletes documents from the index based on a query
   
   client
   : connection to work with (will be hidden by fn-generator)
   
   q
   : string (the query expressing what documents to delete)"
  [^SolrClient client q & {:as opts}]
  (->clojure (.deleteByQuery client q)))

(defn optimize
  "Performs an explicit optimize, causing a merge of all segments to one.
   Note: In most cases it is not required to do explicit optimize
   
   client
   : connection to work with (will be hidden by fn-generator)
   
   waitFlush
   : [Optional ctor2] block until index changes are flushed to disk
   
   wait-searcher
   : [Optional ctor2] block until a new searcher is opened and registered 
     as the main query searcher, making the changes visible
   
   max-segments
   : [Optional ctor3] optimizes down to at most this number of segments"
  ([^SolrClient client]
     (->clojure (.optimize client)))
  ([^SolrClient client wait-flush wait-searcher]
     (->clojure (.optimize client wait-flush wait-searcher)))
  ([^SolrClient client wait-flush wait-searcher max-segments]
     (->clojure
      (.optimize client wait-flush wait-searcher max-segments))))

(defn rollback 
  "Performs a rollback of all non-committed documents pending. Note that this is not a true rollback as in databases. Content you have previously added may have been committed due to autoCommit, buffer full, other client performing a commit etc.
   Also note that rollbacks reset changes made by all clients. Use this method carefully when multiple clients, or multithreaded clients are in use.
   
   client
   : connection to work with (will be hidden by fn-generator)"
  [^SolrClient client]
  (->clojure (.rollback client)))

(defn shutdown  
  "Only applicable to embedded.
   
   Function not more exist in Core and Cloud!   
   [See docs](https://lucene.apache.org/solr/8_5_2/solr-solrj/org/apache/solr/client/solrj/SolrClient.html)
   
   client
   : embedded solr to shutdown"  
  [^SolrClient client]
  (.shutdown client))

(defn ping 
  "Issues a ping request to check if the server is alive
   
   client
   : connection to work with (will be hidden by fn-generator)"
  [^SolrClient client]
  (->clojure (.ping client)))

