(ns flux.collections
  (:require [flux.client :as client]
            [flux.query :as q]))

(defn all-replicas
  "Returns all replicas of given collection
   by quering the clusterstatus of collections
   
   connection
   : given a connection created by create-collection 
   
   collection
   : the collection to search for"
  [connection collection]
  (let [request (q/create-query-request :get "/admin/collections"
                                        {:action "clusterstatus" :collection (name collection)})
        response (client/request connection request)
        shards (get-in response [:cluster :collections "shards"])]
    (into {} (map (fn [[_ v]] (get v "replicas")) shards))))

;; # Filter FNs

(defn active?
  "Filter-FN:
   Returns true if replica is in active state"
  [[_ {:strs [state]}]]
  (= "active" state))

(defn recovering?
  "Filter-FN:
   Returns true if replica is in recovery state"
  [[_ {:strs [state]}]]
  (= "recovery" state))

(defn down?
  "Filter-FN:
   Returns true if replica is in down state"
  [[_ {:strs [state]}]]
  (= "down" state))

(defn not-active?
  "Filter-FN:
   Returns true if replica is not in active state"
  [replica]
  (not (active? replica)))

(defn node-name
  "Filter-FN:
   Returns the node name of the replica"
  [[_ {:strs [node_name]}]]
  node_name)

(letfn [ ;; Returns the solr node name for given host/port
        (solr-node-name [host-port]
          (str host-port "_solr"))]
  
  (defn hosted-by?
    "Special Filter-FN:
     Returns true if given replica is hosted locally by given host/port
     used to generate lists of replicas of a collection hosted by host/port
     
     replica
     : x or % - the value to compare against, usually a list generated by all-replicas
     
     host-port
     : string host:port to search for"
    [replica host-port]
    (= (node-name replica) (solr-node-name host-port))))

(defn leader?
  "Filter-FN:
   Returns true if given replica is a leader"
  [[_ {:keys [leader]}]]
  (= "true" leader))

(letfn [(try-all-replicas [connection collection]
          (try
            (all-replicas connection collection)
            ;; TODO: catch specific exc.. not throwable
            (catch Throwable _ {})))]
  
  (defn wait-until-active
    "Waits (infinitely) until all solr replicas hosted by given host/port belonging to given collection are in active state
        
   connection
   : given a connection created by create-collection 
   
   collection
   : the collection to search for
     
   host-port
   : string host:port to search for"
    
    [connection collection host-port]
    (loop [replicas (try-all-replicas connection collection)]
      (when-not (->> replicas
                     (filter active?)
                     (filter #(hosted-by? %1 host-port))
                     (seq))
        ;; TODO: allow optional timeout val
        (Thread/sleep 1000)
        (recur (try-all-replicas connection collection))))))

;; # Collection management

(defn create-collection
  "Create a SolrCloud collection
   
   connection
   : given a connection created by create-collection 
   
   collection-name
   : string. Name of collection to create
   
   num-shards 
   : integer. The number of shards this collection will be split into
   
   replication-factor
   : [optional] integer. The number of replicas to be created for each shard.
   
   params
   : [optional] map. Additional configuration to crate a collection.
     Reserved keys: action, name, numShards and replicationFactor
     Possible keys: router.name, shards, nrtReplicas, tlogReplicas,
     pullReplicas, maxShardsPerNode, createNodeSet, createNodeSet.shuffle,
     collection.configName, router.field, property.name=value (core.properties),
     autoAddReplicas, async, rule, snitch, policy, waitForFinalState, withCollection,
     alias
   
   See https://lucene.apache.org/solr/guide/8_5/collection-management.html#create for more info."
  ([connection collection-name num-shards]
   (create-collection connection collection-name num-shards 1 {}))
  ([connection collection-name num-shards replication-factor]
   (create-collection connection collection-name num-shards replication-factor {}))
  ([connection collection-name num-shards replication-factor params]
   (let [with-params (assoc params
                            "action" "create"
                            "name" (name collection-name)
                            "numShards" num-shards
                            "replicationFactor" replication-factor)]
     (client/request
      connection
      (q/create-query-request :get "/admin/collections" with-params)))))

(defn delete-collection
  "Delete a SolrCloud collection
   
   connection
   : given a connection created by create-collection 
   
   collection-name
   : name of collection to delete"
  [connection collection-name]
  (let [with-params {"action" "delete" "name" (name collection-name)}]
    (client/request
     connection
     (q/create-query-request :get "/admin/collections" with-params))))

(defn changeDefaultCollection
  "Change the default collection to work with
   
   connection
   : given a connection created by create-collection 
   
   collection-name
   : name of collection to use"
  [connection collection-name]
  (.setDefaultCollection connection (name collection-name)))